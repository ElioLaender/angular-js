Módulos:

O angular JS trabalha a partir de módulos, onde devemos ter o módulo principal, responsável por startar a aplicação. Chamamos nosso módulo principal no arquivo de index da aplicação, por exemplo dentro de um arquivo chamado main.js

Importanto framework:

No html principal, devemos realizar a importação do arquivo do angularJS no arquivo. A partir do momento que temos a importação do script do angularJS, já podemos acessar suas propriedades, desde que o arquivo que o chame tenha acesso aos recursos importados, por isso devemos realizar a chamada no index.html do projeto. 

Angular expression:

{{}} : Atrávés dessa expressão, conseguimos acessar no template variáveis que estão nos controllers. Caso o valor não exita, não será informado nada. 

////////////////////

Controllers:

Devemos criar o controller, que serve de intermediário entre a view e a model. Seguido uma base de projetos mcv, temos o diretórios específicos para a camada view, model e controller. 

Como no caso do módule, nosso script controller também deverá ser importado na view em que o mesmo é utilizado. 

////////////////////
Diretivas:

ng-app="nomeController" // Declara um módulo dentro do html, lembrando que dentro de um módule declaramos o controller. 
ng-controller="NomeController" //Declara um determinado controller dentro do html.

////////////////////

Escopos AngularJS:

Toda variável declarada dentro de um controller, por exemplo, só é vísivel dentro do escopo da function que declarou a mesma, ex:

angular.module('alurapic').controller('FotosController', function() {
	var olá = "olá";
});

Para contornarmos essa situação, o angular fornece o '$scope', que quando declarada torna as variáveis acessíveis para o bloco html onde o controller for chamado, ex:

angular.module('alurapic').controller('FotosController', function($scope) {
	$scope.ola = "olá";
});

//////////////////////

* Vejamos as seguintes afirmações sobre Angular:

- Angular é um script como outro qualquer, por isso precisa ser importado em nossa página através da tag script.
- A diretiva ng-app possui como valor o nome do módulo que desejamos carregar assim que nossa página for carregada.
- Um módulo pode ter de 0 a N dependências.

Precisamos importar o script do Angular como fazemos com qualquer outro, como os demais módulos criados, por exemplo. Além disso temos de carregar um módulo através da diretiva ng-app. Esses por sua vez podem carregar ou não demais módulos, isto é, suas dependências.
////////////////////////

angular.module('alurapic'); // uso
module('alurapic', []); // criação

* Criamos um módulo através do objeto global angular passando dois parâmetros: o nome do módulo e um array com suas dependências, que pode ser vazio caso não possua. No exemplo angular.module('alurapic'); estamos apenas acessar um módulo já existente.

angular.module('contabilidade', []).controller('LancamentosController', function() { });angular.module('estoque').controller('Provisao', function($scope) { });

* Um controller pode ser criado com um módulo ou mais tarde adicionado em um módulo já existente. A função controller recebe como primeiro parâmetro o nome do controller e como segundo a função que o define.
/////////
angular.module('alurapic').controller('FotosController', function($scope) {
  $scope.foto = {
      titulo : 'Leão',
      url: 'http://fotosdoalem.com/leao.jpg'
  };
});

* A comunicação entre um controller e uma view é feita através do objeto $scope, que representa o escopo de um controller. Qualquer propriedade adicionada neste objeto estará disponível na view e acessível através de AEs, para o elemento onde definimos o escopo do controller, assim como seus filhos.

////////

1 - Data binding significa associação de dado, isto é, podemos associar um dado à view através de Angular Expression e qualquer mudança nesse dado refletirá na sua apresentação na view.

2 - Uma Angular Expression (AE) é somente leitura, isto é, alterações dos dados na view não se propaga para o model.

3 - Um model no Angular pode ser um objeto ou qualquer tipo literal do JavaScript, como String ou Boolean.

4 - Angular não é uma solução que se coaduna com a prática de Progressive Enhancement no que diz respeito a criação de páginas web.

* Uma AE é somente leitura, nossa view lê a informação no escopo do controller, mas não é capaz de atualizá-la. Este tipo de associação é chamado de one-way data binding, a informação flui do controller para a view. Aliás, esse dado associado à view pode ser qualquer tipo literal do JavaScript, inclusive um objeto.

Angular não se coaduna com a prática do Progressive Enhancement, no qual criamos uma página usando um simples HTML e CSS, usando JavaScript apenas para adicionar melhorias. Com Angular, se o JavaScript estiver desativado ou não for suportado, nada da aplicação funcionará.

///////////

* O Angular permite repetir marcações HTML através da diretiva ng-repeat. Primeiro, precisamos adicioná-la no elemento que desejamos repetir, segundo, precisamos indicar na diretiva a propriedade em $scope do controller que será iterada. Dentro desse contexto, temos um exemplo abaixo do uso da diretiva:

<p ng-repeat="frase in frases">{{frase}}</p>

//////////

* Angular possui seu próprio sistema de injeção de dependências, podendo a dependência ser injetada em qualquer posição:

angular.module('alurapic').controller('a', function($http, $scope) {});
angular.module('alurapic').controller('c', function($scope, $http) {});

//////////

Angular fornece um serviço exclusivo para realização de requisição Ajax, o $http. Vejamos algumas afirmativas sobre este serviço:

1) Pode ser injetado como qualquer outro artefato do Angular

2) Possui a função .get, que recebe como parâmetro um endereço, inclusive é especializada na leitura de dados.

3) A função .get retorna uma promise.

4) Podemos usar .then e .catch para obter os dados e capturar erros respectivamente ou .success e .error, açúcares sintáticos com a mesma finalidade.

* Todas as sentenças são verdadeiras. Existem outras funções em $http responsáveis pelo envio, remoção e atualização de dados quando seguimos o padrão REST(seus verbos).

////////////

Exemplo de declaração de um controller e configuração correta de um elemento da view para usar a diretiva ng-repeat:

// controller
angular.module('alurapic').controller('NomeDoController', function($scope) {
   $scope.letras = ['A', 'B', 'C'];
});

// na view

<ul ng-controller="NomeDoController">
    <li ng-repeat="letra in letras">{{letra}}</li>
</ul>

/////////////

* Temos as seguintes declarações sobre diretivas:
- Diretivas são criadas através da função .directive
- Diretivas são componentes do Angular que ensinam novos truques para o navegador

Diretivas são componentes reutilizáveis que podem encapsular marcação e comportamento. São criadas sempre dentro de um módulo através da função .directive. Toda diretiva deve sempre retornar um DDO (Directive Definition Object) configurado para que funcione

/////////////

<abas-dinamicas-especiais></abas-dinamicas-especiais> e <div abas-dinamicas-especiais></div>

Com a propriedade restrict declaramos que ela pode ser utilizada tanto como atributo (A), quanto como elemento (E). Mesmo usando camelCase na definição da diretiva, devemos utilizar o hífen na marcação HTML.

* Definindo um template html em arquivo separado:

- A propriedade url não faz parte de um DDO, mas temos a propriedade templateUrl, que permite criar um arquivo HTML separado para toda a marcação HTML dessa diretiva, indicando apenas o caminho para o arquivo. Alternativamente podemos usar a propriedade template com toda marcação necessária da diretiva.

/////////////////

* Veja o uso de uma diretiva para mostrar os dados de um usuario logado:
<usuario-logado nome-completo="{{usuario.nome-completo}}"></usuario-logado>

angular.module('minhasDiretivas', [])
    .directive('usuarioLogado', function() {

        var ddo = {};
        ddo.restrict = "AE";

        ddo.scope = {
            nome: 'AQUI'
        };

        return ddo;
    });

Repare que o atributo no elemento HTML se chama nome-completo e na diretiva usamos apenas nome. Se os dois fossem iguais, bastaria colocar @ no lugar de AQUI. Mas, como possuem nomes diferentes, é preciso ser explícito na declaração do scope usando @nome-completo para capturar o valor do atributo.

///////////////////

Two way data binding:

Diferente da Angular Expression (AE) que é somente leitura (one-way data binding), a diretiva ng-model permite ler e propagar alterações de dados a partir da view.

Associação de dados multidirecional. Para isso, precisamos utilizar o ng-model="" passando o nome da variável responsável por receber este valor no controller. 

Filtrando dados de um array:

O ng-repeat permite que seja passado um filtro para o mesmo através do operador pipe '|', dessa forma podemos passar o filter, informando qual variável será utilizada
na aplicação do filtro. 

ng-repeat="foto in fotos | filter: filtro"

Quando usamos filter, todas as propriedades dos objetos são vasculhadas à procura do valor digitado. E se quisermos buscar apenas, por exemplo, pelo nome do funcionário? Podemos fazer essa forma:

ng-repeat="funcionario in funcionarios | filter: {nome: textoFiltro} "


///////////////////

Qual a diferença entre a diretiva ng-model e Angular Expression (AE)?

O primeiro lê e grava no model, enquanto o segundo apenas lê.

A diretiva ng-model permite ler e também alterar o model associado (two-way data binding). 
É muito comum em telas de cadastro, onde precisamos capturar os dados do usuário para depois enviá-los numa requisição Ajax, por exemplo. Já a Angular Expression (AE) apenas lê o model (one-way data binding).

///////////////////
Temos as seguintes frases a respeito da diretiva ng-model-options:

1) Serve para postergar a atualização do modelo (dado).

2) Sua unidade de trabalho é em milissegundos, passada através da propriedade debounce.

3) Não pode ser usada sem a diretiva ng-model

4) Pode vir antes ou depois da diretiva ng-model sem problemas.

Não faz sentido usarmos ng-model-options sem ng-model, já que a primeira passa opções especiais para a segunda. 
A diretiva ng-model-options pode ser usada para postergar a atualização do model, recebendo um objeto com a propriedade debounce com valor em milissegundos. A ordem de escrita não é importante.

Como o Angular sabe qual diretiva aplicar primeiro? Internamente, todas as diretivas do angular possuem a propriedade priority. 
Por exemplo, a diretiva ng-model possui a prioridade 1 enquanto a ng-model-options 0. A diretiva ng-repeat possui prioridade 1000. Diretivas com menor número de prioridade são aplicadas primeiro. Isso faz todo sentido, pois ng-model-options precisa ser aplicada antes de ng-model entrar em ação. É por isso que a ordem da diretiva no elemento da tag HTML não dita quem será aplicado primeiro, mas sim a prioridade.

/////////////////////
ngAnimate:

* No mundo CSS, não é incomum termos uma classe declarada que é ativada apenas quando algum elemento tiver essa classe. 
Geralmente, podemos adicionar e remover classes via JavaScript, o que permite a aplicação condicional do estilo.
O Angular possui o módulo ngAnimate, que pode nos ajudar nessa tarefa. Sobre este módulo podemos afirmar que:

- Quando carregado, faz com que algumas diretivas do core do Angular adicionem e removam classes dinamicamente. 
Porém, não temos controle das classes adicionadas e precisamos recorrer à documentação para ver aquelas que nos interessam.

- É um módulo que não faz parte do core do Angular.

O módulo ngAnimate precisa ser carregado, uma vez que o módulo core angular.min.js não o carrega automaticamente. Este módulo, apesar do nome sugestivo, não traz qualquer animação pronta para uso, ele apenas habilita para uma série de diretivas a capacidade de adicionarem ou removerem classes de acordo com o estado de seus elementos. Fazendo uma analogia com CSS, é como se fossem pseudo classes.